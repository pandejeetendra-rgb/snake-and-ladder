<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Saap-Seedi GBL — Cyber Security Techniques</title>
<style>
  :root{
    --bg1:#070A12;
    --bg2:#0B1631;
    --card:#0f1d3cdd;
    --ink:#eaf2ff;
    --muted:#b7c6e6;
    --accent:#5dd6ff;
    --accent2:#a78bfa;
    --good:#34d399;
    --bad:#fb7185;
    --warn:#fbbf24;
    --line:#21335e;
    --shadow: 0 18px 50px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:radial-gradient(1200px 800px at 30% 20%, var(--bg2), var(--bg1));color:var(--ink);}

  .app{max-width:1100px;margin:0 auto;padding:14px;min-height:100%;display:flex;flex-direction:column;gap:12px;}
  header{
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    padding:10px 12px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-radius:16px;box-shadow:var(--shadow);
  }
  .brand{display:flex;align-items:center;gap:10px}
  .logo{
    width:42px;height:42px;border-radius:14px;
    background:conic-gradient(from 120deg, var(--accent), var(--accent2), var(--good), var(--accent));
    box-shadow:0 12px 30px rgba(93,214,255,.18);
    position:relative;overflow:hidden;
  }
  .logo:after{
    content:"";position:absolute;inset:-40%;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
    transform:rotate(18deg);
  }
  .title{display:flex;flex-direction:column;line-height:1.1}
  .title b{font-size:16px;letter-spacing:.2px}
  .title span{font-size:12px;color:var(--muted)}
  .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pill{
    display:flex;gap:8px;align-items:center;
    padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.15);
    font-size:12px;color:var(--muted);
  }
  .dot{width:8px;height:8px;border-radius:50%;}
  .dot.g{background:var(--good)}
  .dot.p{background:var(--accent2)}
  .dot.c{background:var(--accent)}
  .btn{
    border:0;border-radius:12px;padding:10px 12px;
    color:var(--ink);background:linear-gradient(180deg, rgba(93,214,255,.22), rgba(93,214,255,.08));
    border:1px solid rgba(93,214,255,.35);
    box-shadow:0 10px 26px rgba(93,214,255,.12);
    cursor:pointer;font-weight:700;letter-spacing:.2px;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{
    background:linear-gradient(180deg, rgba(167,139,250,.20), rgba(167,139,250,.08));
    border-color:rgba(167,139,250,.35);
    box-shadow:0 10px 26px rgba(167,139,250,.12);
  }

  .main{
    display:grid;grid-template-columns: 1.25fr .75fr;gap:12px;align-items:stretch;flex:1;
  }
  @media (max-width: 900px){
    .main{grid-template-columns:1fr; }
  }

  .panel{
    border-radius:18px;border:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    box-shadow:var(--shadow);
    overflow:hidden;
  }

  /* Board panel */
  .boardWrap{padding:10px;display:flex;flex-direction:column;gap:10px;}
  .boardTop{
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  }
  .turnTag{
    display:flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.15);
    font-size:12px;color:var(--muted);
  }
  .turnTag b{color:var(--ink)}
  .canvasHolder{
    position:relative;border-radius:16px;overflow:hidden;
    border:1px solid rgba(255,255,255,.08);
    background:radial-gradient(900px 700px at 20% 10%, rgba(93,214,255,.12), rgba(0,0,0,.25));
    min-height:340px;
  }
  canvas{display:block;width:100%;height:100%}
  .overlayToast{
    position:absolute;left:50%;top:16px;transform:translateX(-50%);
    padding:10px 14px;border-radius:999px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);
    color:var(--ink);font-weight:800;font-size:13px;letter-spacing:.2px;
    box-shadow:0 14px 35px rgba(0,0,0,.35);
    opacity:0;pointer-events:none;
  }
  .overlayToast.show{animation:toastPop .7s ease forwards;}
  @keyframes toastPop{
    0%{opacity:0;transform:translateX(-50%) translateY(-8px) scale(.96)}
    25%{opacity:1;transform:translateX(-50%) translateY(0) scale(1)}
    85%{opacity:1}
    100%{opacity:0;transform:translateX(-50%) translateY(-6px) scale(.98)}
  }

  /* Side panel */
  .side{padding:12px;display:flex;flex-direction:column;gap:12px;}
  .card{
    border-radius:16px;padding:12px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(0,0,0,.20);
  }
  .card h3{margin:0 0 8px;font-size:14px}
  .rows{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;font-size:12px;color:var(--muted)}
  .row b{color:var(--ink)}
  .tiny{font-size:11px;color:rgba(234,242,255,.75);line-height:1.35}
  .kbd{
    font-weight:800;color:var(--ink);
    padding:1px 7px;border-radius:8px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
  }

  /* Dice */
  .diceArea{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .dice{
    width:62px;height:62px;border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    position:relative;display:grid;place-items:center;
    box-shadow:0 12px 30px rgba(0,0,0,.25);
  }
  .dice .face{
    font-weight:1000;font-size:22px;letter-spacing:.5px;
    color:var(--ink);
    text-shadow:0 8px 18px rgba(0,0,0,.35);
  }
  .dice.rolling{animation:diceRoll .85s ease-in-out;}
  @keyframes diceRoll{
    0%{transform:rotate(0deg) scale(1)}
    25%{transform:rotate(18deg) scale(1.03)}
    55%{transform:rotate(-22deg) scale(.98)}
    85%{transform:rotate(12deg) scale(1.02)}
    100%{transform:rotate(0deg) scale(1)}
  }

  /* MCQ screen */
  .mcqScreen{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    background:radial-gradient(900px 700px at 30% 20%, rgba(93,214,255,.16), rgba(0,0,0,.85));
    padding:14px;
    z-index:50;
  }
  .mcqScreen.show{display:flex}
  .mcqCard{
    width:min(860px, 100%); border-radius:20px; padding:14px;
    border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.25));
    box-shadow:0 22px 70px rgba(0,0,0,.55);
  }
  .mcqHead{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .badge{
    padding:6px 10px;border-radius:999px;font-size:12px;font-weight:900;
    border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);color:var(--muted);
  }
  .qtext{
    margin:10px 0 10px;font-size:16px;font-weight:900;line-height:1.25;
  }
  .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width: 700px){
    .choices{grid-template-columns:1fr}
    .qtext{font-size:15px}
  }
  .choice{
    text-align:left;cursor:pointer;
    padding:12px 12px;border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    color:var(--ink);font-weight:800;font-size:13px;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
  }
  .choice:hover{transform:translateY(-1px);border-color:rgba(93,214,255,.35);background:rgba(93,214,255,.08)}
  .choice small{display:block;color:var(--muted);font-weight:700;margin-top:4px}
  .choice.correct{border-color:rgba(52,211,153,.55);background:rgba(52,211,153,.10)}
  .choice.wrong{border-color:rgba(251,113,133,.55);background:rgba(251,113,133,.10)}
  .mcqFoot{margin-top:10px;display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .feedback{
    min-height:18px;color:rgba(234,242,255,.88);font-size:12px;line-height:1.35;
  }
  .bigPop{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:60;
    pointer-events:none;
  }
  .bigPop.show{display:flex;animation:popIn .55s ease forwards;}
  .bigPop .msg{
    padding:18px 22px;border-radius:22px;font-weight:1000;font-size:34px;letter-spacing:.3px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.45);
    box-shadow:0 22px 70px rgba(0,0,0,.55);
    text-shadow:0 14px 30px rgba(0,0,0,.55);
  }
  @keyframes popIn{
    0%{opacity:0;transform:scale(.94)}
    25%{opacity:1;transform:scale(1)}
    100%{opacity:0;transform:scale(.98)}
  }

  /* Tiny shake for wrong answer */
  .shake{animation:shake .25s ease-in-out}
  @keyframes shake{
    0%{transform:translateX(0)}
    20%{transform:translateX(-3px)}
    45%{transform:translateX(3px)}
    70%{transform:translateX(-2px)}
    100%{transform:translateX(0)}
  }
</style>
</head>
<body>
<div class="app">
  <header class="panel">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">
        <b>Saap-Seedi GBL (Learner vs Computer)</b>
        <span>Snakes & Ladders + MCQs from “Cyber Security Techniques”</span>
      </div>
    </div>
    <div class="hud">
      <div class="pill"><span class="dot g"></span> Learner: <b id="sLearner">0</b></div>
      <div class="pill"><span class="dot c"></span> Computer: <b id="sComp">0</b></div>
      <div class="pill"><span class="dot p"></span> Correct: <b id="sCorrect">0</b> / <b id="sTotal">0</b></div>
      <button class="btn secondary" id="btnReset" title="Start a fresh match">Reset</button>
    </div>
  </header>

  <div class="main">
    <section class="panel boardWrap">
      <div class="boardTop">
        <div class="turnTag" id="turnTag"><b>Turn:</b> Learner</div>

        <div class="diceArea">
          <div class="dice" id="diceBox" aria-label="Dice">
            <div class="face" id="diceFace">—</div>
          </div>
          <button class="btn" id="btnRoll">Roll Dice</button>
        </div>
      </div>

      <div class="canvasHolder" id="canvasHolder">
        <div class="overlayToast" id="toast"></div>
        <canvas id="board"></canvas>
      </div>
    </section>

    <aside class="panel side">
      <div class="card">
        <h3>How learning controls the game</h3>
        <div class="tiny">
          <div class="rows">
            <div class="row"><span><span class="kbd">Dice</span> decides steps</span><b>Luck</b></div>
            <div class="row"><span><span class="kbd">Ladder</span> asks bonus MCQ</span><b>Correct = climb</b></div>
            <div class="row"><span><span class="kbd">Snake</span> asks save MCQ</span><b>Correct = avoid</b></div>
          </div>
          <div style="margin-top:8px;color:rgba(234,242,255,.78)">
            The game flips between MCQ screen and the board so the board fits well on phones.
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Controls</h3>
        <div class="tiny">
          <div class="row"><span>Roll</span><b>Tap “Roll Dice”</b></div>
          <div class="row"><span>Answer MCQ</span><b>Tap an option</b></div>
          <div class="row"><span>Finish rule</span><b>Exact 100</b></div>
          <div class="row"><span>Computer accuracy</span><b id="accTxt">65%</b></div>
        </div>
      </div>

      <div class="card">
        <h3>Status</h3>
        <div class="rows tiny">
          <div class="row"><span>Last move</span><b id="lastMove">—</b></div>
          <div class="row"><span>Special</span><b id="lastSpecial">—</b></div>
          <div class="row"><span>MCQ context</span><b id="lastCtx">—</b></div>
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- MCQ Overlay -->
<div class="mcqScreen" id="mcqScreen" role="dialog" aria-modal="true">
  <div class="mcqCard" id="mcqCard">
    <div class="mcqHead">
      <div class="badge" id="mcqBadge">MCQ</div>
      <div class="badge" id="mcqPlayer">Player: Learner</div>
    </div>
    <div class="qtext" id="qtext">Question</div>
    <div class="choices" id="choices"></div>
    <div class="mcqFoot">
      <div class="feedback" id="feedback"></div>
      <button class="btn secondary" id="btnCloseMCQ" style="display:none">Continue</button>
    </div>
  </div>
</div>

<!-- Big popup -->
<div class="bigPop" id="bigPop"><div class="msg" id="bigMsg">Correct!</div></div>

<script>
/* =========================
   MCQs derived from the uploaded chapter
   (Authentication, Encryption, Digital Signatures, Antivirus, Firewall, Steganography)
   ========================= */

const QUESTION_BANK = [
  {id:"Q1", q:"Authentication is primarily the process of:", a:[
    "Granting permissions to resources",
    "Identifying a user and verifying they are who they claim to be",
    "Encrypting data before sending",
    "Scanning for viruses"
  ], correct:1, fb:"Authentication verifies identity (for example, username + password, OTP, biometrics)."},
  {id:"Q2", q:"OTP stands for:", a:[
    "One Time Password",
    "Open Transfer Protocol",
    "Online Trusted Password",
    "One Token Process"
  ], correct:0, fb:"OTP is typically sent by SMS/email and is valid for one-time use."},
  {id:"Q3", q:"Two-factor authentication (2FA) typically requires:", a:[
    "Two usernames",
    "Two different types of evidence for identity",
    "Two computers",
    "Two email addresses"
  ], correct:1, fb:"2FA combines factors like password + OTP/biometric/physical token."},
  {id:"Q4", q:"Authorization refers to:", a:[
    "Verifying who a user is",
    "Converting plaintext into ciphertext",
    "Giving access to resources based on credentials/rights",
    "Detecting worms and trojans"
  ], correct:2, fb:"Authentication verifies identity; authorization grants access based on roles/rights."},
  {id:"Q5", q:"A strong password policy commonly recommends:", a:[
    "Short passwords for easy recall",
    "More than 12 characters with mixed character types",
    "Only lowercase letters",
    "Changing password once in 5 years"
  ], correct:1, fb:"Longer + mixed characters reduces guessability and brute-force success."},

  {id:"Q6", q:"Encryption is best described as:", a:[
    "Hiding messages inside images only",
    "Locking data by converting it into unreadable form using algorithms",
    "Blocking network ports",
    "Validating a document’s content"
  ], correct:1, fb:"Encryption converts readable data to coded form; decryption restores it using a key."},
  {id:"Q7", q:"Decryption is the process of:", a:[
    "Converting coded data back to original text using a key",
    "Sending the key via SMS",
    "Dropping network packets",
    "Checking a firewall rule"
  ], correct:0, fb:"Decryption reverses encryption when the correct key is available."},
  {id:"Q8", q:"If the same key is used to encrypt and decrypt, it is called:", a:[
    "Asymmetric encryption",
    "Symmetric key encryption",
    "Public key encryption only",
    "Token encryption"
  ], correct:1, fb:"Symmetric encryption uses one shared key for both locking and unlocking."},
  {id:"Q9", q:"In asymmetric encryption, which statement is correct?", a:[
    "Public and private keys are the same",
    "Encryption and decryption keys are different",
    "Only private keys are shared publicly",
    "No keys are required"
  ], correct:1, fb:"Asymmetric uses a public key (shared) and a private key (kept secret)."},
  {id:"Q10", q:"If A sends a secret message to B using asymmetric encryption, A typically encrypts using:", a:[
    "A’s private key",
    "A’s public key",
    "B’s public key",
    "B’s private key"
  ], correct:2, fb:"Encrypt with receiver’s public key; receiver decrypts using their private key."},

  {id:"Q11", q:"Digital signatures mainly help with:", a:[
    "Data validation and sender authentication",
    "Virus removal",
    "Network address translation",
    "Hiding IP addresses only"
  ], correct:0, fb:"Digital signatures support integrity (no tampering) and authenticity (who signed)."},
  {id:"Q12", q:"A digital signature is created by encrypting data with:", a:[
    "Receiver’s public key",
    "Sender’s private key",
    "Receiver’s private key",
    "Sender’s public key"
  ], correct:1, fb:"The receiver verifies by decrypting signature using sender’s public key."},
  {id:"Q13", q:"If a message is tampered during transmission, digital signatures help because:", a:[
    "The receiver can detect mismatch during verification",
    "The hacker can re-sign easily",
    "The message becomes automatically encrypted",
    "The firewall blocks all tampering"
  ], correct:0, fb:"Verification fails if content changes; attacker cannot re-sign without sender’s private key."},
  {id:"Q14", q:"Digital signatures also help prevent later denial of a transaction. This is often called:", a:[
    "Compression",
    "Non-repudiation",
    "Packet filtering",
    "Steganalysis"
  ], correct:1, fb:"Non-repudiation means the signer cannot easily deny signing later."},

  {id:"Q15", q:"Antivirus software is mainly designed to:", a:[
    "Encrypt files before sending",
    "Detect and remove malicious code like viruses/worms/trojans",
    "Replace strong passwords",
    "Act as a proxy server"
  ], correct:1, fb:"Antivirus prevents and removes malware and typically updates signatures frequently."},
  {id:"Q16", q:"A firewall is best described as:", a:[
    "A tool to hide messages in images",
    "A network security system that controls incoming/outgoing traffic using rules",
    "A password generator only",
    "A document validation tool"
  ], correct:1, fb:"Firewalls monitor and control traffic between trusted and untrusted networks."},
  {id:"Q17", q:"Network layer firewalls (packet filters) mainly check:", a:[
    "Only the font style in emails",
    "Packet headers and rule matching at lower TCP/IP layers",
    "Audio noise patterns",
    "Only application window titles"
  ], correct:1, fb:"Packet filters apply rules using fields like IP/port/protocol/state."},
  {id:"Q18", q:"Stateful firewall differs from stateless because it:", a:[
    "Cannot filter traffic",
    "Maintains records of active sessions to speed processing",
    "Only works for emails",
    "Always blocks all traffic"
  ], correct:1, fb:"Stateful uses connection state; stateless checks each packet independently."},
  {id:"Q19", q:"Application-layer firewalls typically filter:", a:[
    "On a per-process/application basis",
    "Only on a per-country basis",
    "Only based on image pixels",
    "Only based on keyboard speed"
  ], correct:0, fb:"Application firewalls can allow/block traffic depending on the specific app/process."},
  {id:"Q20", q:"A proxy server can act like a firewall by:", a:[
    "Responding to requests on behalf of a network user and blocking others",
    "Changing private keys into public keys",
    "Removing viruses from USB drives only",
    "Replacing the operating system"
  ], correct:0, fb:"Proxy gateways can mediate requests and enforce filtering for specific applications."},
  {id:"Q21", q:"NAT (Network Address Translation) in firewalls is commonly used to:", a:[
    "Increase monitor brightness",
    "Hide internal private addresses and reduce public IP needs",
    "Create digital signatures",
    "Store OTP messages"
  ], correct:1, fb:"NAT maps private internal addresses to public addresses and can obscure internal topology."},
  {id:"Q22", q:"Software-based personal firewalls are often valuable because they:", a:[
    "Only run on routers",
    "Can identify which applications are creating network risks",
    "Never need updates",
    "Replace all encryption"
  ], correct:1, fb:"They can alert when a new/malicious program tries to access the network."},
  {id:"Q23", q:"Hardware firewalls are commonly found in:", a:[
    "Broadband routers and firewall appliances",
    "Only smartphone cameras",
    "Only spreadsheets",
    "Only PDF readers"
  ], correct:0, fb:"Hardware firewalls are often built into routers and protect multiple devices on a LAN."},

  {id:"Q24", q:"Steganography is the technique of:", a:[
    "Encrypting with public/private keys",
    "Hiding secret messages inside media so the message is not obvious",
    "Dropping suspicious packets",
    "Scanning hard disks for malware"
  ], correct:1, fb:"Steganography hides existence of the message (often in image/audio/video)."},
  {id:"Q25", q:"In image steganography, one common approach is altering:", a:[
    "Most significant bits so changes are obvious",
    "Least significant bits so changes are hard to notice",
    "Only the file name",
    "Only the screen resolution"
  ], correct:1, fb:"LSB changes can be visually subtle, especially in high-resolution images."},
];

/* =========================
   Board setup (10x10, 1..100 serpentine)
   ========================= */

const JUMPS = {
  // Ladders
  3: 22,
  5: 8,
  11: 26,
  20: 29,
  27: 56,
  36: 44,
  51: 67,
  71: 92,
  80: 99,
  // Snakes
  17: 4,
  19: 7,
  21: 9,
  43: 34,
  49: 30,
  62: 18,
  64: 60,
  87: 24,
  95: 75,
  98: 79
};

const SAFE_SQUARES = new Set([1, 25, 50, 75, 100]); // simple safe squares for spark burst

/* =========================
   Game state
   ========================= */
const state = {
  players: [
    { name:"Learner", pos:1, color:"#34d399", trail:[], score:0 },
    { name:"Computer", pos:1, color:"#5dd6ff", trail:[], score:0 }
  ],
  turn: 0,
  busy: false,
  exactFinish: true,
  lastMove: "—",
  lastSpecial: "—",
  lastCtx: "—",
  correct: 0,
  total: 0,
  computerAccuracy: 0.65,
  usedQ: new Set()
};

/* =========================
   DOM hooks
   ========================= */
const canvas = document.getElementById("board");
const holder = document.getElementById("canvasHolder");
const ctx = canvas.getContext("2d");

const btnRoll = document.getElementById("btnRoll");
const btnReset = document.getElementById("btnReset");
const diceBox = document.getElementById("diceBox");
const diceFace = document.getElementById("diceFace");
const turnTag = document.getElementById("turnTag");

const sLearner = document.getElementById("sLearner");
const sComp = document.getElementById("sComp");
const sCorrect = document.getElementById("sCorrect");
const sTotal = document.getElementById("sTotal");
const lastMove = document.getElementById("lastMove");
const lastSpecial = document.getElementById("lastSpecial");
const lastCtx = document.getElementById("lastCtx");
const accTxt = document.getElementById("accTxt");

const toast = document.getElementById("toast");

const mcqScreen = document.getElementById("mcqScreen");
const mcqBadge = document.getElementById("mcqBadge");
const mcqPlayer = document.getElementById("mcqPlayer");
const qtext = document.getElementById("qtext");
const choices = document.getElementById("choices");
const feedback = document.getElementById("feedback");
const btnCloseMCQ = document.getElementById("btnCloseMCQ");

const bigPop = document.getElementById("bigPop");
const bigMsg = document.getElementById("bigMsg");
const mcqCard = document.getElementById("mcqCard");

accTxt.textContent = Math.round(state.computerAccuracy*100) + "%";

/* =========================
   Utilities
   ========================= */
const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
const randInt = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

function showToast(text){
  toast.textContent = text;
  toast.classList.remove("show");
  void toast.offsetWidth; // reflow
  toast.classList.add("show");
}
function showBig(text, good=true){
  bigMsg.textContent = text;
  bigMsg.style.borderColor = good ? "rgba(52,211,153,.55)" : "rgba(251,113,133,.55)";
  bigMsg.style.background = good ? "rgba(52,211,153,.10)" : "rgba(251,113,133,.10)";
  bigPop.classList.remove("show");
  void bigPop.offsetWidth;
  bigPop.classList.add("show");
}

/* =========================
   Board geometry
   ========================= */
let W=0,H=0, pad=14, grid=10, cell=0;

function resize(){
  const rect = holder.getBoundingClientRect();
  W = Math.floor(rect.width);
  H = Math.max(360, Math.floor(rect.height));
  canvas.width = W * devicePixelRatio;
  canvas.height = H * devicePixelRatio;
  canvas.style.width = W+"px";
  canvas.style.height = H+"px";
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  cell = Math.floor((Math.min(W,H) - pad*2)/grid);
}
window.addEventListener("resize", ()=>{ resize(); render(); });

function squareToRC(n){
  // n: 1..100
  const idx = n-1;
  const rFromBottom = Math.floor(idx/10); // 0..9
  const row = 9 - rFromBottom; // 9..0 top
  const colInRow = idx % 10;
  const isLeftToRight = (rFromBottom % 2 === 0);
  const col = isLeftToRight ? colInRow : (9-colInRow);
  return {row, col};
}

function centerOfSquare(n){
  const {row,col} = squareToRC(n);
  const x = pad + col*cell + cell/2;
  const y = pad + row*cell + cell/2;
  return {x,y};
}

/* =========================
   Particles (trail, sparks, confetti)
   ========================= */
const particles = [];
function addSpark(x,y, count=18){
  for(let i=0;i<count;i++){
    particles.push({
      x,y, vx:(Math.random()*2-1)*2.4, vy:(Math.random()*2-1)*2.4,
      life: 520 + Math.random()*240,
      t:0,
      kind:"spark"
    });
  }
}
function addConfetti(x,y, count=70){
  for(let i=0;i<count;i++){
    particles.push({
      x,y, vx:(Math.random()*2-1)*3.0, vy:(Math.random()*-1)*3.6 - 0.8,
      life: 950 + Math.random()*450,
      t:0,
      kind:"confetti"
    });
  }
}

let lastFrame = performance.now();
function tick(now){
  const dt = now - lastFrame;
  lastFrame = now;
  // update particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.t += dt;
    if(p.kind==="confetti"){
      p.vy += 0.012*dt; // gravity
      p.vx *= 0.998;
    }else{
      p.vx *= 0.995;
      p.vy *= 0.995;
    }
    p.x += p.vx;
    p.y += p.vy;
    if(p.t > p.life) particles.splice(i,1);
  }
  render();
  requestAnimationFrame(tick);
}

/* =========================
   Drawing helpers
   ========================= */
function roundedRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawBoard(){
  // background glow
  ctx.clearRect(0,0,W,H);

  // subtle grid background
  ctx.save();
  ctx.globalAlpha = 0.9;

  // board area
  const boardSize = cell*grid;
  const bx = pad, by = pad;
  const br = 18;

  // board plate
  ctx.fillStyle = "rgba(0,0,0,.20)";
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  roundedRect(bx-6, by-6, boardSize+12, boardSize+12, br);
  ctx.fill();
  ctx.stroke();

  // cells
  for(let r=0;r<grid;r++){
    for(let c=0;c<grid;c++){
      const x = bx + c*cell;
      const y = by + r*cell;
      const isAlt = (r+c)%2===0;
      const g = isAlt ? "rgba(93,214,255,.06)" : "rgba(167,139,250,.05)";
      ctx.fillStyle = g;
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.lineWidth = 1;
      roundedRect(x+2,y+2,cell-4,cell-4,12);
      ctx.fill();
      ctx.stroke();
    }
  }

  // numbers (lightweight)
  ctx.fillStyle = "rgba(234,242,255,.52)";
  ctx.font = "700 10px system-ui";
  for(let n=1;n<=100;n++){
    const {row,col} = squareToRC(n);
    const x = bx + col*cell + 6;
    const y = by + row*cell + 13;
    ctx.fillText(String(n), x, y);
  }

  ctx.restore();

  // draw ladders/snakes
  drawLinks();
}

function drawLinks(){
  // Ladders as bright segments, snakes as curved segments
  for(const [kStr, v] of Object.entries(JUMPS)){
    const from = Number(kStr);
    const to = v;
    const a = centerOfSquare(from);
    const b = centerOfSquare(to);

    if(to > from){
      // ladder
      ctx.save();
      ctx.lineWidth = 7;
      ctx.strokeStyle = "rgba(52,211,153,.30)";
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();

      // ladder rails
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(234,242,255,.30)";
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      ctx.beginPath();
      ctx.moveTo(a.x+nx*8, a.y+ny*8);
      ctx.lineTo(b.x+nx*8, b.y+ny*8);
      ctx.moveTo(a.x-nx*8, a.y-ny*8);
      ctx.lineTo(b.x-nx*8, b.y-ny*8);
      ctx.stroke();

      // rungs
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(93,214,255,.28)";
      const steps = 6;
      for(let i=1;i<steps;i++){
        const t = i/steps;
        const rx = a.x + dx*t;
        const ry = a.y + dy*t;
        ctx.beginPath();
        ctx.moveTo(rx+nx*7, ry+ny*7);
        ctx.lineTo(rx-nx*7, ry-ny*7);
        ctx.stroke();
      }
      ctx.restore();
    } else {
      // snake
      ctx.save();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(251,113,133,.30)";
      ctx.beginPath();
      const midx = (a.x+b.x)/2 + (Math.random()*18-9);
      const midy = (a.y+b.y)/2 + (Math.random()*18-9);
      ctx.moveTo(a.x,a.y);
      ctx.quadraticCurveTo(midx, midy, b.x,b.y);
      ctx.stroke();

      // snake highlight
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(234,242,255,.16)";
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.quadraticCurveTo(midx+6, midy-6, b.x,b.y);
      ctx.stroke();
      ctx.restore();
    }
  }
}

function drawToken(player){
  const {x,y} = centerOfSquare(player.pos);

  // trail (short)
  player.trail.push({x,y,t:performance.now()});
  if(player.trail.length>10) player.trail.shift();

  // draw trail
  ctx.save();
  for(let i=0;i<player.trail.length;i++){
    const p = player.trail[i];
    const alpha = (i+1)/player.trail.length * 0.20;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 10 - (player.trail.length-i)*0.6, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // token
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,.40)";
  ctx.shadowBlur = 18;
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(x,y,12,0,Math.PI*2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // ring
  ctx.strokeStyle = "rgba(234,242,255,.65)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x,y,12,0,Math.PI*2);
  ctx.stroke();

  // label
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.font = "900 10px system-ui";
  ctx.fillText(player.name==="Learner" ? "L" : "C", x-3.5, y+3.5);

  ctx.restore();
}

function drawParticles(){
  ctx.save();
  for(const p of particles){
    const life = 1 - (p.t / p.life);
    if(p.kind==="spark"){
      ctx.globalAlpha = Math.max(0, life);
      ctx.fillStyle = "rgba(251,191,36,.95)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.globalAlpha = Math.max(0, life);
      // confetti tiny rectangles (random colors chosen at draw time but stable-ish)
      const hue = (p.x*2 + p.y*3) % 360;
      ctx.fillStyle = `hsla(${hue}, 85%, 65%, ${Math.max(0,life)})`;
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate((p.x+p.y)*0.01);
      ctx.fillRect(-2,-2,4,4);
      ctx.restore();
    }
  }
  ctx.restore();
}

function render(){
  drawBoard();
  drawParticles();
  // tokens
  drawToken(state.players[0]);
  drawToken(state.players[1]);
}

/* =========================
   Dice animation
   ========================= */
async function rollDiceAnimated(){
  diceBox.classList.add("rolling");
  const spins = 10;
  for(let i=0;i<spins;i++){
    diceFace.textContent = String(randInt(1,6));
    await sleep(60);
  }
  const val = randInt(1,6);
  diceFace.textContent = String(val);
  await sleep(180);
  diceBox.classList.remove("rolling");
  return val;
}

/* =========================
   Movement animation (step-by-step)
   ========================= */
async function animateSteps(player, from, to, stepDelay=150){
  if(to === from) return;
  const dir = (to>from)?1:-1;
  let p = from;
  while(p !== to){
    p += dir;
    player.pos = p;
    if(SAFE_SQUARES.has(p)) addSpark(centerOfSquare(p).x, centerOfSquare(p).y, 10);
    await sleep(stepDelay);
  }
}

async function animateJump(player, from, to, type){
  const delay = type==="ladder" ? 110 : 130;
  await animateSteps(player, from, to, delay);
}

/* =========================
   Question selection (avoid repeating until exhausted)
   ========================= */
function pickQuestion(){
  // try to avoid repeats
  const available = QUESTION_BANK.filter(q => !state.usedQ.has(q.id));
  const pool = available.length ? available : QUESTION_BANK;
  const q = pool[randInt(0, pool.length-1)];
  state.usedQ.add(q.id);
  return q;
}

/* =========================
   MCQ UI (flip screen)
   ========================= */
function openMCQ({playerName, contextLabel, badgeLabel}){
  mcqPlayer.textContent = "Player: " + playerName;
  mcqBadge.textContent = badgeLabel;
  feedback.textContent = "";
  choices.innerHTML = "";
  btnCloseMCQ.style.display = "none";
  mcqScreen.classList.add("show");
  mcqCard.classList.remove("shake");
}

function closeMCQ(){
  mcqScreen.classList.remove("show");
}

async function askMCQ({playerIndex, context}){
  const player = state.players[playerIndex];
  const q = pickQuestion();
  state.total += 1;
  sTotal.textContent = String(state.total);

  const badgeLabel =
    context.type==="ladder" ? "Ladder Bonus MCQ" :
    context.type==="snake"  ? "Snake Save MCQ" :
    "MCQ";

  openMCQ({playerName: player.name, contextLabel: context.type, badgeLabel});
  qtext.textContent = q.q;

  // build options
  let resolved = false;
  let resolveFn;
  const promise = new Promise(r => resolveFn = r);

  const letters = ["A","B","C","D"];
  q.a.forEach((txt, idx)=>{
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.innerHTML = `<b>${letters[idx]}.</b> ${txt}`;
    btn.addEventListener("click", async ()=>{
      if(resolved) return;
      resolved = true;

      // lock all
      [...choices.querySelectorAll("button")].forEach(b=>b.disabled = true);

      const correct = (idx === q.correct);
      if(correct){
        btn.classList.add("correct");
        state.correct += 1;
        sCorrect.textContent = String(state.correct);
        showBig("Correct!", true);
      }else{
        btn.classList.add("wrong");
        // highlight correct
        const correctBtn = choices.querySelectorAll("button")[q.correct];
        if(correctBtn) correctBtn.classList.add("correct");
        showBig("Wrong!", false);
        mcqCard.classList.add("shake");
      }

      feedback.textContent = q.fb;

      // short visible pause, then close
      await sleep(900);
      btnCloseMCQ.style.display = "inline-block";
      btnCloseMCQ.disabled = false;

      // auto continue after a small extra delay (so mobile users can read)
      await sleep(600);
      btnCloseMCQ.style.display = "none";
      closeMCQ();
      resolveFn(correct);
    });
    choices.appendChild(btn);
  });

  // Computer: we still show the MCQ briefly (for transparency) but auto-answers
  if(player.name === "Computer"){
    // disable click to avoid confusion
    [...choices.querySelectorAll("button")].forEach(b=>b.disabled = true);
    await sleep(650);

    const willBeCorrect = Math.random() < state.computerAccuracy;
    const chosen = willBeCorrect ? q.correct : pickWrongIndex(q.correct);
    const btns = [...choices.querySelectorAll("button")];

    btns[chosen].classList.add(willBeCorrect ? "correct" : "wrong");
    btns[q.correct].classList.add("correct");

    if(willBeCorrect){
      state.correct += 1;
      sCorrect.textContent = String(state.correct);
      showBig("Computer: Correct!", true);
    }else{
      showBig("Computer: Wrong!", false);
      mcqCard.classList.add("shake");
    }

    feedback.textContent = q.fb;

    await sleep(900);
    closeMCQ();
    resolveFn(willBeCorrect);
  }

  return promise;
}

function pickWrongIndex(correctIdx){
  const picks = [0,1,2,3].filter(i=>i!==correctIdx);
  return picks[randInt(0,picks.length-1)];
}

/* =========================
   Special square logic
   ========================= */
function getJump(pos){
  const to = JUMPS[pos];
  if(!to) return null;
  return {to, type: to>pos ? "ladder" : "snake"};
}

/* =========================
   Turn engine
   ========================= */
function updateHUD(){
  sLearner.textContent = String(state.players[0].pos);
  sComp.textContent = String(state.players[1].pos);
  lastMove.textContent = state.lastMove;
  lastSpecial.textContent = state.lastSpecial;
  lastCtx.textContent = state.lastCtx;
  turnTag.innerHTML = `<b>Turn:</b> ${state.players[state.turn].name}`;
  btnRoll.disabled = state.busy || state.players[state.turn].name !== "Learner";
}

async function takeTurn(){
  if(state.busy) return;
  state.busy = true;
  updateHUD();

  const playerIndex = state.turn;
  const player = state.players[playerIndex];

  // Roll dice (human: button already pressed; computer: auto)
  const dice = await rollDiceAnimated();

  const start = player.pos;
  let tentative = start + dice;

  if(state.exactFinish && tentative > 100){
    tentative = start;
    showToast("Exact 100 needed. No move.");
  } else {
    showToast(`${player.name} rolled ${dice}`);
  }

  state.lastCtx = "Dice move";
  state.lastMove = `${player.name}: ${start} → ${tentative} (dice ${dice})`;
  state.lastSpecial = "—";
  updateHUD();

  // animate movement on board
  await sleep(250);
  await animateSteps(player, start, tentative, 150);
  await sleep(450);

  // check special
  const landed = player.pos;
  const jump = getJump(landed);

  if(jump){
    const isLadder = jump.type==="ladder";
    state.lastSpecial = isLadder ? `Ladder at ${landed} → ${jump.to}` : `Snake at ${landed} → ${jump.to}`;
    state.lastCtx = isLadder ? "Ladder bonus MCQ" : "Snake save MCQ";
    updateHUD();

    // flip to MCQ screen
    await sleep(450);
    const correct = await askMCQ({
      playerIndex,
      context: {type: jump.type, from: landed, to: jump.to}
    });

    // back to board, then apply result
    await sleep(250);

    if(isLadder){
      if(correct){
        showToast("Correct! Climb the ladder.");
        await sleep(300);
        await animateJump(player, landed, jump.to, "ladder");
      }else{
        showToast("Wrong. No ladder ride.");
      }
    }else{
      if(correct){
        showToast("Correct! You avoided the snake bite.");
      }else{
        showToast("Wrong! Snake bite… sliding down.");
        // tiny screen shake for the board container
        holder.classList.add("shake");
        setTimeout(()=>holder.classList.remove("shake"), 260);
        await sleep(300);
        await animateJump(player, landed, jump.to, "snake");
      }
    }
    await sleep(450);
  }

  // win check
  if(player.pos === 100){
    showToast(`${player.name} reached HOME!`);
    const {x,y} = centerOfSquare(100);
    addConfetti(x,y, 120);
    await sleep(900);
    alert(`${player.name} wins!`);
    state.busy = false;
    updateHUD();
    return;
  }

  // switch turn
  state.turn = (state.turn+1)%2;
  state.busy = false;
  updateHUD();

  // Computer auto turn with a pleasant delay
  if(state.players[state.turn].name === "Computer"){
    await sleep(650);
    takeTurn();
  }
}

/* =========================
   Buttons
   ========================= */
btnRoll.addEventListener("click", async ()=>{
  if(state.busy) return;
  if(state.players[state.turn].name !== "Learner") return;
  takeTurn();
});

btnReset.addEventListener("click", ()=>{
  state.players[0].pos = 1; state.players[1].pos = 1;
  state.players[0].trail = []; state.players[1].trail = [];
  state.turn = 0;
  state.busy = false;
  state.lastMove = "—";
  state.lastSpecial = "—";
  state.lastCtx = "—";
  state.correct = 0;
  state.total = 0;
  state.usedQ.clear();
  diceFace.textContent = "—";
  particles.length = 0;
  sCorrect.textContent = "0";
  sTotal.textContent = "0";
  updateHUD();
  render();
  showToast("Reset done. Learner starts.");
});

/* =========================
   Init
   ========================= */
function init(){
  resize();
  updateHUD();
  render();
  showToast("Tap Roll Dice to start.");
  requestAnimationFrame(tick);
}
init();
</script>
</body>
</html>
