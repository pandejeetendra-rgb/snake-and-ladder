<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Saap-Seedi GBL — Two Screen</title>
<style>
  :root{
    --bg1:#070A12;
    --bg2:#0B1631;
    --ink:#eaf2ff;
    --muted:#b7c6e6;
    --accent:#5dd6ff;
    --accent2:#a78bfa;
    --good:#34d399;
    --bad:#fb7185;
    --warn:#fbbf24;
    --shadow: 0 18px 50px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:radial-gradient(1200px 800px at 30% 20%, var(--bg2), var(--bg1));color:var(--ink);}

  .app{max-width:1100px;margin:0 auto;padding:14px;min-height:100%;display:flex;flex-direction:column;gap:12px;}
  header{
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    padding:10px 12px;border:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-radius:16px;box-shadow:var(--shadow);
  }
  .brand{display:flex;align-items:center;gap:10px}
  .logo{
    width:42px;height:42px;border-radius:14px;
    background:conic-gradient(from 120deg, var(--accent), var(--accent2), var(--good), var(--accent));
    box-shadow:0 12px 30px rgba(93,214,255,.18);
    position:relative;overflow:hidden;
  }
  .logo:after{
    content:"";position:absolute;inset:-40%;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
    transform:rotate(18deg);
  }
  .title{display:flex;flex-direction:column;line-height:1.1}
  .title b{font-size:16px;letter-spacing:.2px}
  .title span{font-size:12px;color:var(--muted)}
  .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pill{
    display:flex;gap:8px;align-items:center;
    padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.15);
    font-size:12px;color:var(--muted);
  }
  .dot{width:8px;height:8px;border-radius:50%;}
  .dot.g{background:var(--good)}
  .dot.c{background:var(--accent)}
  .dot.p{background:var(--accent2)}
  .btn{
    border:0;border-radius:12px;padding:10px 12px;
    color:var(--ink);background:linear-gradient(180deg, rgba(93,214,255,.22), rgba(93,214,255,.08));
    border:1px solid rgba(93,214,255,.35);
    box-shadow:0 10px 26px rgba(93,214,255,.12);
    cursor:pointer;font-weight:900;letter-spacing:.2px;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{
    background:linear-gradient(180deg, rgba(167,139,250,.20), rgba(167,139,250,.08));
    border-color:rgba(167,139,250,.35);
    box-shadow:0 10px 26px rgba(167,139,250,.12);
  }

  .main{
    display:grid;grid-template-columns: 1.25fr .75fr;gap:12px;align-items:stretch;flex:1;
  }
  @media (max-width: 900px){
    .main{grid-template-columns:1fr;}
  }
  .panel{
    border-radius:18px;border:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    box-shadow:var(--shadow);
    overflow:hidden;
  }

  /* GAME VIEW */
  .boardWrap{padding:10px;display:flex;flex-direction:column;gap:10px;}
  .boardTop{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}
  .turnTag{
    display:flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.15);
    font-size:12px;color:var(--muted);
  }
  .turnTag b{color:var(--ink)}
  .diceArea{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .dice{
    width:62px;height:62px;border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    display:grid;place-items:center;
    box-shadow:0 12px 30px rgba(0,0,0,.25);
  }
  .dice .face{font-weight:1100;font-size:22px;color:var(--ink);text-shadow:0 8px 18px rgba(0,0,0,.35);}
  .dice.rolling{animation:diceRoll .85s ease-in-out;}
  @keyframes diceRoll{
    0%{transform:rotate(0deg) scale(1)}
    25%{transform:rotate(18deg) scale(1.03)}
    55%{transform:rotate(-22deg) scale(.98)}
    85%{transform:rotate(12deg) scale(1.02)}
    100%{transform:rotate(0deg) scale(1)}
  }

  .canvasHolder{
    position:relative;border-radius:16px;overflow:hidden;
    border:1px solid rgba(255,255,255,.08);
    background:radial-gradient(900px 700px at 20% 10%, rgba(93,214,255,.12), rgba(0,0,0,.25));
    width:100%;
    aspect-ratio: 1 / 1;
    min-height: 320px;
  }
  canvas{display:block;width:100%;height:100%}

  .overlayToast{
    position:absolute;left:50%;top:14px;transform:translateX(-50%);
    padding:10px 14px;border-radius:999px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);
    color:var(--ink);font-weight:1000;font-size:13px;
    box-shadow:0 14px 35px rgba(0,0,0,.35);
    opacity:0;pointer-events:none;
  }
  .overlayToast.show{animation:toastPop .95s ease forwards;}
  @keyframes toastPop{
    0%{opacity:0;transform:translateX(-50%) translateY(-8px) scale(.96)}
    25%{opacity:1;transform:translateX(-50%) translateY(0) scale(1)}
    82%{opacity:1}
    100%{opacity:0;transform:translateX(-50%) translateY(-6px) scale(.98)}
  }

  /* Side panel */
  .side{padding:12px;display:flex;flex-direction:column;gap:12px;}
  .card{
    border-radius:16px;padding:12px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(0,0,0,.20);
  }
  .card h3{margin:0 0 8px;font-size:14px}
  .rows{display:flex;flex-direction:column;gap:8px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;font-size:12px;color:var(--muted)}
  .row b{color:var(--ink)}
  .tiny{font-size:11px;color:rgba(234,242,255,.75);line-height:1.35}
  .kbd{
    font-weight:1000;color:var(--ink);
    padding:1px 7px;border-radius:8px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
  }

  /* TWO SCREEN MCQ */
  .screen{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;
    padding:14px;z-index:100;
    background:radial-gradient(900px 700px at 30% 20%, rgba(93,214,255,.16), rgba(0,0,0,.86));
  }
  .screen.show{display:flex}
  .mcqCard{
    width:min(920px,100%); border-radius:20px; padding:14px;
    border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.25));
    box-shadow:0 22px 70px rgba(0,0,0,.55);
  }
  .mcqHead{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .badge{
    padding:6px 10px;border-radius:999px;font-size:12px;font-weight:1100;
    border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.25);color:var(--muted);
  }
  .qtext{margin:10px 0 10px;font-size:16px;font-weight:1100;line-height:1.25;}
  .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width: 700px){ .choices{grid-template-columns:1fr} .qtext{font-size:15px} }
  .choice{
    text-align:left;cursor:pointer;
    padding:12px;border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    color:var(--ink);font-weight:1000;font-size:13px;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
  }
  .choice:hover{transform:translateY(-1px);border-color:rgba(93,214,255,.35);background:rgba(93,214,255,.08)}
  .choice.correct{border-color:rgba(52,211,153,.55);background:rgba(52,211,153,.10)}
  .choice.wrong{border-color:rgba(251,113,133,.55);background:rgba(251,113,133,.10)}
  .mcqFoot{margin-top:10px;display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .feedback{min-height:18px;color:rgba(234,242,255,.88);font-size:12px;line-height:1.35;}
  .bigPop{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:150;
    pointer-events:none;
  }
  .bigPop.show{display:flex;animation:popIn .55s ease forwards;}
  .bigPop .msg{
    padding:18px 22px;border-radius:22px;font-weight:1200;font-size:34px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.45);
    box-shadow:0 22px 70px rgba(0,0,0,.55);
    text-shadow:0 14px 30px rgba(0,0,0,.55);
  }
  @keyframes popIn{
    0%{opacity:0;transform:scale(.94)}
    25%{opacity:1;transform:scale(1)}
    100%{opacity:0;transform:scale(.98)}
  }
  .shake{animation:shake .25s ease-in-out}
  @keyframes shake{
    0%{transform:translateX(0)}
    20%{transform:translateX(-3px)}
    45%{transform:translateX(3px)}
    70%{transform:translateX(-2px)}
    100%{transform:translateX(0)}
  }
</style>
</head>
<body>
<div class="app">
  <header class="panel">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">
        <b>Saap-Seedi GBL (Learner vs Computer)</b>
        <span>Slower flip + readable Computer MCQ + large question bank</span>
      </div>
    </div>
    <div class="hud">
      <div class="pill"><span class="dot g"></span> Learner: <b id="pLearner">1</b></div>
      <div class="pill"><span class="dot c"></span> Computer: <b id="pComp">1</b></div>
      <div class="pill"><span class="dot p"></span> Correct: <b id="sCorrect">0</b> / <b id="sTotal">0</b></div>
      <button class="btn secondary" id="btnReset">Reset</button>
    </div>
  </header>

  <div class="main">
    <section class="panel boardWrap">
      <div class="boardTop">
        <div class="turnTag" id="turnTag"><b>Turn:</b> Learner</div>
        <div class="diceArea">
          <div class="dice" id="diceBox"><div class="face" id="diceFace">—</div></div>
          <button class="btn" id="btnRoll">Start Turn</button>
        </div>
      </div>

      <div class="canvasHolder" id="canvasHolder">
        <div class="overlayToast" id="toast"></div>
        <canvas id="board"></canvas>
      </div>
    </section>

    <aside class="panel side">
      <div class="card">
        <h3>Rules</h3>
        <div class="tiny rows">
          <div class="row"><span><span class="kbd">Every turn</span></span><b>1 MCQ</b></div>
          <div class="row"><span>Correct MCQ</span><b>Climb ladders + avoid snakes</b></div>
          <div class="row"><span>Wrong MCQ</span><b>Ladders blocked + snakes bite</b></div>
          <div class="row"><span>Finish rule</span><b>Exact 100</b></div>
        </div>
      </div>

      <div class="card">
        <h3>Status</h3>
        <div class="tiny rows">
          <div class="row"><span>Last action</span><b id="lastAction">—</b></div>
          <div class="row"><span>Special</span><b id="lastSpecial">—</b></div>
          <div class="row"><span>MCQ result</span><b id="lastMCQ">—</b></div>
          <div class="row"><span>Question</span><b id="qCount">0 / 0</b></div>
        </div>
      </div>

      <div class="card">
        <h3>Computer</h3>
        <div class="tiny rows">
          <div class="row"><span>Accuracy</span><b id="accTxt">65%</b></div>
          <div class="row"><span>MCQ visible time</span><b>Long</b></div>
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- MCQ SCREEN -->
<div class="screen" id="mcqScreen" role="dialog" aria-modal="true">
  <div class="mcqCard" id="mcqCard">
    <div class="mcqHead">
      <div class="badge" id="mcqBadge">Turn MCQ</div>
      <div class="badge" id="mcqPlayer">Player: Learner</div>
    </div>
    <div class="qtext" id="qtext">Question</div>
    <div class="choices" id="choices"></div>
    <div class="mcqFoot">
      <div class="feedback" id="feedback"></div>
      <button class="btn secondary" id="btnContinue" style="display:none">Continue</button>
    </div>
  </div>
</div>

<!-- Big popup -->
<div class="bigPop" id="bigPop"><div class="msg" id="bigMsg">Correct!</div></div>

<script>
/* =========================
   TIMING (tune here)
   ========================= */
const TIMING = {
  // screen flip feel
  flipIntoMCQ: 550,          // before MCQ becomes "interactive"
  flipBackToBoard: 650,      // after MCQ closes, before dice starts

  // learner reading times
  learnerFeedbackHold: 1700, // after answering, keep feedback visible
  learnerAutoCloseExtra: 1200, // additional time before auto-close (still shows Continue briefly)

  // computer readability
  computerReadBeforeAnswer: 1800, // keep question visible before computer answers
  computerFeedbackHold: 1700,     // keep feedback visible after computer answer

  // pacing between steps
  afterDiceRollPause: 320,
  afterMovePause: 520,
  betweenTurnsPause: 900,

  // movement speed
  stepDelay: 155,
  ladderStepDelay: 120,
  snakeStepDelay: 150
};

/* =========================
   QUESTION BANK (40 items)
   Based on chapter: Authentication, Encryption, Digital Signatures,
   Antivirus, Firewall + types, Software/Hardware firewalls, Steganography
   ========================= */
const QUESTION_BANK = [
  // Authentication (8)
  {id:"Q01", q:"Authentication is mainly used to:", a:[
    "Decide user permissions only",
    "Identify and verify a user’s identity",
    "Convert plaintext to ciphertext",
    "Detect trojans in a file"
  ], correct:1, fb:"Authentication verifies identity (who you are)."},
  {id:"Q02", q:"A common authentication pair mentioned in practice is:", a:[
    "Username and password",
    "IP address and MAC address",
    "Firewall and antivirus",
    "Ciphertext and plaintext"
  ], correct:0, fb:"Username and password are basic identity checks."},
  {id:"Q03", q:"OTP is commonly used along with username/password as:", a:[
    "A second factor",
    "A firewall rule",
    "A hashing algorithm",
    "A malware type"
  ], correct:0, fb:"OTP is an extra verification step (2FA style)."},
  {id:"Q04", q:"Authentication is especially important when users connect:", a:[
    "Only inside the office LAN",
    "Over internet to the company network (remote access)",
    "Only on offline systems",
    "Only for image files"
  ], correct:1, fb:"Remote access increases risk; authentication becomes more critical."},
  {id:"Q05", q:"Which of these is an example of an authentication method?", a:[
    "Packet filtering",
    "Digital watermarking",
    "Biometrics",
    "Network Address Translation"
  ], correct:2, fb:"Biometrics verifies identity using physical traits."},
  {id:"Q06", q:"Authentication focuses on:", a:[
    "Who the user is",
    "What the user can access",
    "How data is compressed",
    "How packets are routed"
  ], correct:0, fb:"Authorization decides access; authentication confirms identity."},
  {id:"Q07", q:"Two-factor authentication means:", a:[
    "Two passwords",
    "Two different categories of identity evidence",
    "Two routers",
    "Two encryption keys"
  ], correct:1, fb:"Example: password + OTP/biometric."},
  {id:"Q08", q:"In security, authentication is best seen as a control to reduce:", a:[
    "Unauthorized access",
    "Image size",
    "Network speed",
    "Keyboard errors"
  ], correct:0, fb:"It blocks access unless identity is verified."},

  // Encryption (9)
  {id:"Q09", q:"Encryption is a technique to:", a:[
    "Convert data into unreadable form",
    "Block malware automatically",
    "Hide a message inside an image",
    "Detect open ports"
  ], correct:0, fb:"Encryption converts readable data into coded form."},
  {id:"Q10", q:"Decryption is:", a:[
    "Converting unreadable data back to original data",
    "Deleting suspicious files",
    "Blocking incoming packets",
    "Changing IP addresses"
  ], correct:0, fb:"Decryption restores the original message using a key."},
  {id:"Q11", q:"If the same key locks and unlocks data, it is:", a:[
    "Asymmetric encryption",
    "Symmetric key encryption",
    "No-key encryption",
    "Steganography"
  ], correct:1, fb:"Symmetric encryption uses one shared key."},
  {id:"Q12", q:"In symmetric encryption, after coding the data, the key is:", a:[
    "Shared with receiver securely to decrypt",
    "Always stored publicly",
    "Never required",
    "Replaced by a firewall"
  ], correct:0, fb:"Receiver needs the same key to decrypt."},
  {id:"Q13", q:"Asymmetric encryption uses:", a:[
    "One shared key only",
    "Two keys (public and private)",
    "No keys",
    "Only passwords"
  ], correct:1, fb:"Public/private key pair is used."},
  {id:"Q14", q:"A correct statement about public/private key encryption is:", a:[
    "Both keys must be identical",
    "Public key is shared; private key is kept secret",
    "Private key is shared publicly",
    "Keys are not needed for decryption"
  ], correct:1, fb:"Public key can be shared; private key must remain confidential."},
  {id:"Q15", q:"Encryption mainly supports:", a:[
    "Confidentiality",
    "Screen brightness",
    "Packet routing",
    "Keyboard speed"
  ], correct:0, fb:"Encryption protects data from being read by unauthorized parties."},
  {id:"Q16", q:"One simple description of encryption is:", a:[
    "Data locking using algorithm + key",
    "Traffic filtering using rules",
    "Hiding data by changing file extension",
    "Scanning files for viruses"
  ], correct:0, fb:"Encryption is like locking data; decryption unlocks it."},
  {id:"Q17", q:"If a wrong key is used during decryption, the result is usually:", a:[
    "Original readable message",
    "Unreadable/garbled output",
    "Automatic password reset",
    "Firewall blocks the PC"
  ], correct:1, fb:"Without the correct key, original data cannot be reconstructed correctly."},

  // Digital Signatures (7)
  {id:"Q18", q:"Digital signature is a technique mainly used for:", a:[
    "Validation of data",
    "Compression of audio",
    "Port scanning",
    "Changing IP addresses"
  ], correct:0, fb:"It validates integrity and authenticity."},
  {id:"Q19", q:"Validation in digital signature context means:", a:[
    "Checking the data is original and not tampered",
    "Making data unreadable",
    "Hiding data inside images",
    "Blocking network traffic"
  ], correct:0, fb:"Validation checks if the data remains the same and genuine."},
  {id:"Q20", q:"Digital signatures are especially useful because documents are often:", a:[
    "Printed only",
    "Transmitted over internet",
    "Stored only on USB",
    "Never shared"
  ], correct:1, fb:"Internet transmission increases risk of alteration."},
  {id:"Q21", q:"Digital signature helps prevent:", a:[
    "Unpleasant situations due to tampering and disputes",
    "Battery drain",
    "Monitor flicker",
    "Keyboard lag"
  ], correct:0, fb:"It helps verify sender and content integrity."},
  {id:"Q22", q:"For digital signature, which is required?", a:[
    "Only receiver’s password",
    "A technique that proves data is from original sender",
    "Only NAT configuration",
    "Only antivirus update"
  ], correct:1, fb:"Signatures prove originality/authenticity."},
  {id:"Q23", q:"Digital signatures primarily support integrity by:", a:[
    "Allowing tampering without detection",
    "Making changes detectable during verification",
    "Blocking all network connections",
    "Encrypting with the same key always"
  ], correct:1, fb:"If altered, verification fails."},
  {id:"Q24", q:"Digital signatures are used mainly when:", a:[
    "You want hidden data inside files",
    "You want data validation and authenticity",
    "You want to filter packet headers",
    "You want to remove worms"
  ], correct:1, fb:"They validate both origin and integrity."},

  // Antivirus (4)
  {id:"Q25", q:"Antivirus software mainly protects against:", a:[
    "Viruses, worms, trojans and other malicious programs",
    "Only firewall bypass",
    "Only password guessing",
    "Only image steganography"
  ], correct:0, fb:"Antivirus targets malicious code and malware families."},
  {id:"Q26", q:"Antivirus needs frequent updates mainly because:", a:[
    "New malware keeps appearing",
    "Encryption keys expire daily",
    "Routers stop working",
    "NAT changes automatically"
  ], correct:0, fb:"Updates give protection against newly discovered threats."},
  {id:"Q27", q:"A main benefit of antivirus updates is to provide:", a:[
    "Immunity against new viruses/worms etc.",
    "Faster keyboard typing",
    "More screen brightness",
    "Higher internet speed"
  ], correct:0, fb:"Updated signatures/heuristics improve detection and prevention."},
  {id:"Q28", q:"Which list contains only malicious programs?", a:[
    "Virus, worm, trojan",
    "Firewall, NAT, proxy",
    "OTP, username, password",
    "Plaintext, ciphertext, key"
  ], correct:0, fb:"Virus/worm/trojan are malware categories."},

  // Firewall basics (6)
  {id:"Q29", q:"A firewall is a system that:", a:[
    "Monitors and controls network traffic using rules",
    "Creates OTP codes",
    "Only compresses files",
    "Hides messages in images"
  ], correct:0, fb:"Firewalls enforce traffic rules between networks."},
  {id:"Q30", q:"A firewall’s job is to analyze data entering or leaving and:", a:[
    "Forward or drop based on rules",
    "Convert it to ciphertext always",
    "Delete all files",
    "Disable authentication"
  ], correct:0, fb:"It allows or blocks based on policy."},
  {id:"Q31", q:"Windows Firewall is described as:", a:[
    "Hardware inside router only",
    "Software that runs on your computer",
    "A steganography tool",
    "An antivirus update server"
  ], correct:1, fb:"Windows Firewall is a software firewall on the machine."},
  {id:"Q32", q:"Firewall provides protection mainly against:", a:[
    "Attacks coming from outside world",
    "Monitor flicker",
    "Printer issues",
    "Audio noise only"
  ], correct:0, fb:"It reduces exposure to external network attacks."},
  {id:"Q33", q:"A firewall intercepts:", a:[
    "All network communication to/from computer (as per config)",
    "Only keyboard input",
    "Only mouse clicks",
    "Only document formatting"
  ], correct:0, fb:"It examines network traffic paths to the system."},
  {id:"Q34", q:"Firewalls are important because they:", a:[
    "Control unwanted access to a network",
    "Replace encryption always",
    "Replace antivirus always",
    "Make passwords unnecessary"
  ], correct:0, fb:"They enforce a barrier and policy control."},

  // Types of firewalls + NAT/Proxy + software/hardware (6)
  {id:"Q35", q:"Network layer firewalls are also called:", a:[
    "Packet filters",
    "Digital signers",
    "OTP gateways",
    "Stego tools"
  ], correct:0, fb:"Network layer firewalls inspect packet headers."},
  {id:"Q36", q:"Stateful firewall means it:", a:[
    "Tracks the state of connections/sessions",
    "Never checks packets",
    "Works only for emails",
    "Always blocks all traffic"
  ], correct:0, fb:"Stateful filters consider session state for decisions."},
  {id:"Q37", q:"Application-layer firewalls work on:", a:[
    "Application data and app-level policies",
    "Only physical cables",
    "Only keyboard input",
    "Only NAT tables"
  ], correct:0, fb:"They filter based on application rules."},
  {id:"Q38", q:"A proxy server in firewall context acts as:", a:[
    "An interface on behalf of network user",
    "A virus signature file",
    "A private key store",
    "A keyboard driver"
  ], correct:0, fb:"Proxy can mediate requests and apply filtering."},
  {id:"Q39", q:"Network Address Translation (NAT) in firewalls helps by:", a:[
    "Hiding internal addresses and reducing public IP needs",
    "Encrypting files",
    "Removing trojans",
    "Creating OTP"
  ], correct:0, fb:"NAT maps private to public addresses and helps conceal internal network."},
  {id:"Q40", q:"A key benefit of personal/software firewall is:", a:[
    "It can identify risky applications trying network access",
    "It replaces all passwords",
    "It removes malware without antivirus",
    "It encrypts all data automatically"
  ], correct:0, fb:"It can block unsafe applications and alert about network attempts."},

  // Steganography (4)
  {id:"Q41", q:"Steganography is a technique of:", a:[
    "Hiding secret messages inside files so they are not easily suspected",
    "Converting data to ciphertext",
    "Blocking packets in network",
    "Generating digital signatures"
  ], correct:0, fb:"Steganography hides the existence of the message."},
  {id:"Q42", q:"A reason steganography works well is that cover files are:", a:[
    "Not easily suspected",
    "Always blocked by firewalls",
    "Always encrypted already",
    "Always very small"
  ], correct:0, fb:"Images/audio/video are common and don’t raise suspicion easily."},
  {id:"Q43", q:"In image steganography, a common technique is using:", a:[
    "Least Significant Bits (LSB) of pixels",
    "Most Significant Bits only",
    "Only file name changes",
    "Only changing resolution"
  ], correct:0, fb:"LSB changes are subtle and harder to notice."},
  {id:"Q44", q:"If each pixel has RGB and you can hide 1 bit in each color value, you can hide:", a:[
    "3 bits per pixel",
    "1 bit per pixel",
    "8 bits per pixel always",
    "No bits per pixel"
  ], correct:0, fb:"1 bit in R + 1 bit in G + 1 bit in B = 3 bits per pixel."},
];

/* =========================
   Board mapping
   ========================= */
const JUMPS = {
  // Ladders
  3:22, 5:8, 11:26, 20:29, 27:56, 36:44, 51:67, 71:92, 80:99,
  // Snakes
  17:4, 19:7, 21:9, 43:34, 49:30, 62:18, 64:60, 87:24, 95:75, 98:79
};
const SAFE_SQUARES = new Set([1,25,50,75,100]);

/* =========================
   Precompute stable link shapes (no flicker)
   ========================= */
const LINKS = [];
(function buildLinks(){
  for(const [kStr,v] of Object.entries(JUMPS)){
    const from = Number(kStr);
    const to = v;
    const type = to > from ? "ladder" : "snake";
    const seed = (from*97 + to*131) % 1000;
    const wiggle = (seed/1000 - 0.5) * 36;
    LINKS.push({from,to,type,wiggle});
  }
})();

/* =========================
   State
   ========================= */
const state = {
  players: [
    { name:"Learner", pos:1, color:"#34d399", trail:[] },
    { name:"Computer", pos:1, color:"#5dd6ff", trail:[] }
  ],
  turn: 0,
  busy: false,
  exactFinish: true,
  computerAccuracy: 0.65,
  usedQ: new Set(),
  correct: 0,
  total: 0,
  turnMCQCorrect: null
};

/* =========================
   DOM
   ========================= */
const canvas = document.getElementById("board");
const holder = document.getElementById("canvasHolder");
const ctx = canvas.getContext("2d");

const btnRoll = document.getElementById("btnRoll");
const btnReset = document.getElementById("btnReset");

const diceBox = document.getElementById("diceBox");
const diceFace = document.getElementById("diceFace");
const turnTag = document.getElementById("turnTag");

const pLearner = document.getElementById("pLearner");
const pComp = document.getElementById("pComp");
const sCorrect = document.getElementById("sCorrect");
const sTotal = document.getElementById("sTotal");

const lastAction = document.getElementById("lastAction");
const lastSpecial = document.getElementById("lastSpecial");
const lastMCQ = document.getElementById("lastMCQ");
const qCount = document.getElementById("qCount");
document.getElementById("accTxt").textContent = Math.round(state.computerAccuracy*100) + "%";

const toast = document.getElementById("toast");

// MCQ screen
const mcqScreen = document.getElementById("mcqScreen");
const mcqCard = document.getElementById("mcqCard");
const mcqPlayer = document.getElementById("mcqPlayer");
const qtext = document.getElementById("qtext");
const choices = document.getElementById("choices");
const feedback = document.getElementById("feedback");
const btnContinue = document.getElementById("btnContinue");

// big popup
const bigPop = document.getElementById("bigPop");
const bigMsg = document.getElementById("bigMsg");

/* =========================
   Utils
   ========================= */
const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
const randInt = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;

function showToast(text){
  toast.textContent = text;
  toast.classList.remove("show");
  void toast.offsetWidth;
  toast.classList.add("show");
}
function showBig(text, good=true){
  bigMsg.textContent = text;
  bigMsg.style.borderColor = good ? "rgba(52,211,153,.55)" : "rgba(251,113,133,.55)";
  bigMsg.style.background = good ? "rgba(52,211,153,.10)" : "rgba(251,113,133,.10)";
  bigPop.classList.remove("show");
  void bigPop.offsetWidth;
  bigPop.classList.add("show");
}
function openMCQScreen(playerName){
  mcqPlayer.textContent = "Player: " + playerName;
  feedback.textContent = "";
  choices.innerHTML = "";
  btnContinue.style.display = "none";
  mcqScreen.classList.add("show");
  mcqCard.classList.remove("shake");
}
function closeMCQScreen(){
  mcqScreen.classList.remove("show");
}

function pickWrongIndex(correctIdx){
  const picks = [0,1,2,3].filter(i=>i!==correctIdx);
  return picks[randInt(0,picks.length-1)];
}

function pickQuestionNoRepeat(){
  // no repeat until exhausted
  let available = QUESTION_BANK.filter(q => !state.usedQ.has(q.id));
  if(available.length === 0){
    state.usedQ.clear();
    available = QUESTION_BANK.slice();
  }
  const q = available[randInt(0, available.length-1)];
  state.usedQ.add(q.id);
  return q;
}

/* =========================
   Board geometry
   ========================= */
let W=0,H=0,pad=14,grid=10,cell=0;

function resize(){
  const rect = holder.getBoundingClientRect();
  W = Math.floor(rect.width);
  H = Math.floor(rect.height);
  canvas.width = W * devicePixelRatio;
  canvas.height = H * devicePixelRatio;
  canvas.style.width = W+"px";
  canvas.style.height = H+"px";
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  cell = Math.floor((Math.min(W,H) - pad*2)/grid);
  render();
}
window.addEventListener("resize", resize);

function squareToRC(n){
  const idx = n-1;
  const rFromBottom = Math.floor(idx/10);
  const row = 9 - rFromBottom;
  const colInRow = idx % 10;
  const isL2R = (rFromBottom % 2 === 0);
  const col = isL2R ? colInRow : (9-colInRow);
  return {row,col};
}
function centerOfSquare(n){
  const {row,col} = squareToRC(n);
  const x = pad + col*cell + cell/2;
  const y = pad + row*cell + cell/2;
  return {x,y};
}

/* =========================
   Particles
   ========================= */
const particles = [];
function addSpark(x,y,count=16){
  for(let i=0;i<count;i++){
    particles.push({x,y,vx:(Math.random()*2-1)*2.2,vy:(Math.random()*2-1)*2.2,t:0,life:550,kind:"spark"});
  }
}
function addConfetti(x,y,count=90){
  for(let i=0;i<count;i++){
    particles.push({x,y,vx:(Math.random()*2-1)*3.0,vy:(Math.random()*-1)*3.6-0.8,t:0,life:1100,kind:"confetti"});
  }
}

let raf = null;
let lastFrame = performance.now();
function startRenderLoop(){
  if(raf) return;
  lastFrame = performance.now();
  const loop = (now)=>{
    const dt = now - lastFrame;
    lastFrame = now;

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      if(p.kind==="confetti"){ p.vy += 0.012*dt; p.vx *= 0.998; }
      else { p.vx *= 0.995; p.vy *= 0.995; }
      p.x += p.vx; p.y += p.vy;
      if(p.t > p.life) particles.splice(i,1);
    }

    render();

    if(particles.length===0 && !state.busy){
      raf = null;
      return;
    }
    raf = requestAnimationFrame(loop);
  };
  raf = requestAnimationFrame(loop);
}

/* =========================
   Drawing
   ========================= */
function roundedRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawBoard(){
  ctx.clearRect(0,0,W,H);
  const boardSize = cell*grid;
  const bx = pad, by = pad;

  ctx.fillStyle = "rgba(0,0,0,.20)";
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  roundedRect(bx-6, by-6, boardSize+12, boardSize+12, 18);
  ctx.fill(); ctx.stroke();

  for(let r=0;r<grid;r++){
    for(let c=0;c<grid;c++){
      const x = bx + c*cell;
      const y = by + r*cell;
      const isAlt = (r+c)%2===0;
      ctx.fillStyle = isAlt ? "rgba(93,214,255,.06)" : "rgba(167,139,250,.05)";
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      roundedRect(x+2,y+2,cell-4,cell-4,12);
      ctx.fill(); ctx.stroke();
    }
  }

  ctx.fillStyle = "rgba(234,242,255,.52)";
  ctx.font = "900 10px system-ui";
  for(let n=1;n<=100;n++){
    const {row,col} = squareToRC(n);
    const x = bx + col*cell + 6;
    const y = by + row*cell + 13;
    ctx.fillText(String(n), x, y);
  }

  // ladders/snakes stable
  for(const link of LINKS){
    const a = centerOfSquare(link.from);
    const b = centerOfSquare(link.to);

    if(link.type==="ladder"){
      ctx.save();
      ctx.lineWidth = 7;
      ctx.strokeStyle = "rgba(52,211,153,.30)";
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();

      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(234,242,255,.30)";
      const dx = b.x-a.x, dy=b.y-a.y;
      const len = Math.hypot(dx,dy)||1;
      const nx = -dy/len, ny = dx/len;
      ctx.beginPath();
      ctx.moveTo(a.x+nx*8, a.y+ny*8); ctx.lineTo(b.x+nx*8, b.y+ny*8);
      ctx.moveTo(a.x-nx*8, a.y-ny*8); ctx.lineTo(b.x-nx*8, b.y-ny*8);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(93,214,255,.28)";
      for(let i=1;i<6;i++){
        const t = i/6;
        const rx = a.x + dx*t, ry = a.y + dy*t;
        ctx.beginPath();
        ctx.moveTo(rx+nx*7, ry+ny*7);
        ctx.lineTo(rx-nx*7, ry-ny*7);
        ctx.stroke();
      }
      ctx.restore();
    } else {
      ctx.save();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "rgba(251,113,133,.30)";
      const midx = (a.x+b.x)/2 + link.wiggle;
      const midy = (a.y+b.y)/2 - link.wiggle;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.quadraticCurveTo(midx, midy, b.x,b.y);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(234,242,255,.16)";
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.quadraticCurveTo(midx+6, midy-6, b.x,b.y);
      ctx.stroke();
      ctx.restore();
    }
  }
}

function drawToken(player){
  const {x,y} = centerOfSquare(player.pos);
  player.trail.push({x,y});
  if(player.trail.length>10) player.trail.shift();

  ctx.save();
  for(let i=0;i<player.trail.length;i++){
    const p = player.trail[i];
    const alpha = (i+1)/player.trail.length * 0.18;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,10-(player.trail.length-i)*0.6,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,.40)";
  ctx.shadowBlur = 18;
  ctx.fillStyle = player.color;
  ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0;

  ctx.strokeStyle = "rgba(234,242,255,.65)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.font = "1100 10px system-ui";
  ctx.fillText(player.name==="Learner"?"L":"C", x-3.5, y+3.5);
  ctx.restore();
}

function drawParticles(){
  ctx.save();
  for(const p of particles){
    const life = 1 - (p.t/p.life);
    if(life<=0) continue;
    if(p.kind==="spark"){
      ctx.globalAlpha = life;
      ctx.fillStyle = "rgba(251,191,36,.95)";
      ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill();
    } else {
      ctx.globalAlpha = life;
      const hue = (p.x*2 + p.y*3) % 360;
      ctx.fillStyle = `hsla(${hue}, 85%, 65%, ${life})`;
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate((p.x+p.y)*0.01);
      ctx.fillRect(-2,-2,4,4);
      ctx.restore();
    }
  }
  ctx.restore();
}

function render(){
  drawBoard();
  drawParticles();
  drawToken(state.players[0]);
  drawToken(state.players[1]);
}

/* =========================
   Dice + movement
   ========================= */
async function rollDiceAnimated(){
  diceBox.classList.add("rolling");
  for(let i=0;i<10;i++){
    diceFace.textContent = String(randInt(1,6));
    await sleep(60);
  }
  const val = randInt(1,6);
  diceFace.textContent = String(val);
  await sleep(180);
  diceBox.classList.remove("rolling");
  return val;
}

function getJump(pos){
  const to = JUMPS[pos];
  if(!to) return null;
  return {to, type: to>pos ? "ladder" : "snake"};
}

async function animateSteps(player, from, to, delay){
  if(from===to) return;
  const dir = to>from ? 1 : -1;
  let p = from;
  while(p!==to){
    p += dir;
    player.pos = p;
    if(SAFE_SQUARES.has(p)){
      const c = centerOfSquare(p);
      addSpark(c.x,c.y,10);
      startRenderLoop();
    }
    render();
    await sleep(delay);
  }
}

async function animateJump(player, from, to, type){
  const d = (type==="ladder") ? TIMING.ladderStepDelay : TIMING.snakeStepDelay;
  await animateSteps(player, from, to, d);
}

/* =========================
   MCQ logic (slower + readable)
   ========================= */
async function askTurnMCQ(playerIndex){
  const player = state.players[playerIndex];

  // Show MCQ screen
  openMCQScreen(player.name);
  await sleep(TIMING.flipIntoMCQ);

  // Question selection
  const q = pickQuestionNoRepeat();
  state.total += 1;
  sTotal.textContent = String(state.total);
  qCount.textContent = `${state.usedQ.size} / ${QUESTION_BANK.length}`;

  qtext.textContent = q.q;

  const letters = ["A","B","C","D"];
  let resolved = false;
  let resolveFn;
  const promise = new Promise(r => resolveFn = r);

  // Create options
  q.a.forEach((txt, idx)=>{
    const b = document.createElement("button");
    b.className = "choice";
    b.innerHTML = `<b>${letters[idx]}.</b> ${txt}`;
    b.onclick = async ()=>{
      if(resolved) return;
      resolved = true;

      [...choices.querySelectorAll("button")].forEach(x=>x.disabled=true);

      const correct = (idx===q.correct);
      if(correct){
        b.classList.add("correct");
        state.correct += 1;
        sCorrect.textContent = String(state.correct);
        showBig("Correct!", true);
      }else{
        b.classList.add("wrong");
        const corrBtn = choices.querySelectorAll("button")[q.correct];
        if(corrBtn) corrBtn.classList.add("correct");
        showBig("Wrong!", false);
        mcqCard.classList.add("shake");
      }

      feedback.textContent = q.fb;

      // hold for reading
      await sleep(TIMING.learnerFeedbackHold);

      // optional continue
      btnContinue.style.display = "inline-block";
      btnContinue.onclick = ()=>{
        btnContinue.style.display = "none";
        closeMCQScreen();
        resolveFn(correct);
      };

      // auto-close after extra time
      await sleep(TIMING.learnerAutoCloseExtra);
      if(mcqScreen.classList.contains("show")){
        btnContinue.style.display = "none";
        closeMCQScreen();
        resolveFn(correct);
      }
    };
    choices.appendChild(b);
  });

  // Computer: slower and readable
  if(player.name==="Computer"){
    [...choices.querySelectorAll("button")].forEach(x=>x.disabled=true);

    // keep question visible before answer
    await sleep(TIMING.computerReadBeforeAnswer);

    const willBeCorrect = Math.random() < state.computerAccuracy;
    const chosen = willBeCorrect ? q.correct : pickWrongIndex(q.correct);
    const btns = [...choices.querySelectorAll("button")];
    btns[chosen].classList.add(willBeCorrect ? "correct" : "wrong");
    btns[q.correct].classList.add("correct");

    if(willBeCorrect){
      state.correct += 1; sCorrect.textContent = String(state.correct);
      showBig("Computer: Correct!", true);
    }else{
      showBig("Computer: Wrong!", false);
      mcqCard.classList.add("shake");
    }
    feedback.textContent = q.fb;

    // keep feedback visible
    await sleep(TIMING.computerFeedbackHold);

    closeMCQScreen();
    resolveFn(willBeCorrect);
  }

  return promise;
}

/* =========================
   Turn engine
   ========================= */
function updateHUD(){
  pLearner.textContent = String(state.players[0].pos);
  pComp.textContent = String(state.players[1].pos);
  turnTag.innerHTML = `<b>Turn:</b> ${state.players[state.turn].name}`;
  btnRoll.disabled = state.busy || state.players[state.turn].name!=="Learner";
}

async function takeTurn(){
  if(state.busy) return;
  state.busy = true;
  updateHUD();

  const i = state.turn;
  const player = state.players[i];

  lastAction.textContent = "MCQ…";
  lastSpecial.textContent = "—";
  lastMCQ.textContent = "—";

  // 1) MCQ
  const mcqCorrect = await askTurnMCQ(i);
  state.turnMCQCorrect = mcqCorrect;
  lastMCQ.textContent = mcqCorrect ? "Correct" : "Wrong";

  // 2) Back to board pause
  await sleep(TIMING.flipBackToBoard);

  // 3) Dice
  const dice = await rollDiceAnimated();
  showToast(`${player.name} rolled ${dice}`);
  lastAction.textContent = `${player.name}: dice ${dice}`;

  await sleep(TIMING.afterDiceRollPause);

  // 4) move
  const start = player.pos;
  let tentative = start + dice;
  if(state.exactFinish && tentative>100){
    tentative = start;
    showToast("Exact 100 needed. No move.");
  }

  await animateSteps(player, start, tentative, TIMING.stepDelay);

  await sleep(TIMING.afterMovePause);

  // 5) special square depends on MCQ correctness
  const landed = player.pos;
  const jump = getJump(landed);

  if(jump){
    const type = jump.type;
    const dest = jump.to;

    if(type==="ladder"){
      if(mcqCorrect){
        lastSpecial.textContent = `Ladder ${landed} → ${dest}`;
        showToast("Correct turn! Ladder ride.");
        await sleep(380);
        await animateJump(player, landed, dest, "ladder");
      } else {
        lastSpecial.textContent = `Ladder at ${landed} (blocked)`;
        showToast("Wrong turn. Ladder blocked.");
        await sleep(420);
      }
    } else {
      if(mcqCorrect){
        lastSpecial.textContent = `Snake at ${landed} (avoided)`;
        showToast("Correct turn! Snake avoided.");
        await sleep(420);
      } else {
        lastSpecial.textContent = `Snake ${landed} → ${dest}`;
        showToast("Wrong turn! Snake bite.");
        holder.classList.add("shake");
        setTimeout(()=>holder.classList.remove("shake"), 260);
        await sleep(420);
        await animateJump(player, landed, dest, "snake");
      }
    }
  }

  // 6) win
  if(player.pos===100){
    showToast(`${player.name} reached HOME!`);
    const c = centerOfSquare(100);
    addConfetti(c.x,c.y,120);
    startRenderLoop();
    await sleep(900);
    alert(`${player.name} wins!`);
    state.busy = false;
    updateHUD();
    return;
  }

  state.busy = false;
  updateHUD();
  startRenderLoop();

  // switch turn
  state.turn = (state.turn+1)%2;
  updateHUD();

  // computer auto
  if(state.players[state.turn].name==="Computer"){
    await sleep(TIMING.betweenTurnsPause);
    takeTurn();
  }
}

/* =========================
   Buttons
   ========================= */
btnRoll.addEventListener("click", ()=>{
  if(state.players[state.turn].name!=="Learner") return;
  takeTurn();
});

btnReset.addEventListener("click", ()=>{
  state.players[0].pos=1; state.players[1].pos=1;
  state.players[0].trail=[]; state.players[1].trail=[];
  state.turn=0;
  state.busy=false;
  state.usedQ.clear();
  state.correct=0; state.total=0;
  state.turnMCQCorrect=null;
  diceFace.textContent="—";
  particles.length=0;
  sCorrect.textContent="0"; sTotal.textContent="0";
  lastAction.textContent="—"; lastSpecial.textContent="—"; lastMCQ.textContent="—";
  qCount.textContent=`0 / ${QUESTION_BANK.length}`;
  showToast("Reset done. Learner starts.");
  render();
  updateHUD();
});

/* =========================
   Geometry helpers
   ========================= */
function squareToRC(n){
  const idx = n-1;
  const rFromBottom = Math.floor(idx/10);
  const row = 9 - rFromBottom;
  const colInRow = idx % 10;
  const isL2R = (rFromBottom % 2 === 0);
  const col = isL2R ? colInRow : (9-colInRow);
  return {row,col};
}
function centerOfSquare(n){
  const {row,col} = squareToRC(n);
  const x = pad + col*cell + cell/2;
  const y = pad + row*cell + cell/2;
  return {x,y};
}

/* =========================
   Init
   ========================= */
function init(){
  resize();
  updateHUD();
  qCount.textContent = `0 / ${QUESTION_BANK.length}`;
  render();
  showToast("Tap Start Turn.");
}
init();
</script>
</body>
</html>
